\NeedsTeXFormat{LaTeX2e}[1994/06/01]
\ProvidesPackage{tikzviolinplots}[2021/08/20 Violin plot creation in pgfplots]

\RequirePackage{pgfplots}
\RequirePackage{pgfplotstable}
\RequirePackage{ifthen}
\RequirePackage{stringstrings}


\DeclareOption*{\PackageWarning{tikzviolinplots}{Unknown option: ‘\CurrentOption’}}
\ProcessOptions\relax

\newcommand{\violinsetoptions}[3][]{%

	\def\violinscaled{FALSE}
	\def\violindatapoints{FALSE}
	\def\violinaverages{FALSE}
	\def\violinnomirror{FALSE}
	\def\violinreverseaxis{FALSE}
	\def\violinaxisoptions{#2}
	\def\violinotheroptions{#3}

	\@for\kdeoption:=#1\do{
		\noblanks[q]{\kdeoption}
		\ifthenelse{
			\equal{\thestring}{scaled}
		}{
			\def\violinscaled{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{datapoints}
		}{
			\def\violindatapoints{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{averages}
		}{
			\def\violinaverages{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{nomirror}
		}{
			\def\violinnomirror{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{reverseaxis}
		}{
			\def\violinreverseaxis{TRUE}
		}{}
	}

		\ifthenelse{
			\equal{\violinreverseaxis}{TRUE}
		}{
			\begin{axis}[
				\violinaxisoptions,
				\violinotheroptions,
				axis on top,
				yticklabels={,,},
				ymajorticks=false,
			]
			\end{axis}
		}{
			\begin{axis}[
				\violinaxisoptions,
				\violinotheroptions,
				axis on top,
				xticklabels={,,},
				xmajorticks=false,
			]
			\end{axis}
		}


}

\newcommand{\violinplot}[7][]{%


	\def\bandwith{#1}
	\def\thefilename{#2}
	\def\theindex{#3}
	\def\nsamples{#4}
	\def\thedelta{#5}
	\def\thecolor{#6}
	\def\thelabel{#7}

	\pgfplotstableread{\thefilename}\theoldtable

	\pgfplotstablegetrowsof{\theoldtable}
	\pgfmathparse{int(\pgfmathresult-1)}
	\let\pgfcolsize\pgfmathresult

	\pgfmathparse{0}
	\let\kdestddev\pgfmathresult
	\let\kdeaverage\pgfmathresult

	\pgfplotstableforeachcolumnelement{\theindex}\of\theoldtable\as\xi{%
		\pgfmathparse{\kdeaverage+(\xi/(1+\pgfcolsize))}
		\let\kdeaverage\pgfmathresult
	}

	\ifthenelse{
		\equal{\violindatapoints}{TRUE}
	}{
		\pgfplotstablecreatecol[
			create col/assign/.code={
				\let\entry\thedelta
				\pgfkeyslet{/pgfplots/table/create col/next content}\entry
			}
		]{deltacol}\theoldtable
	}{}

	\ifthenelse{
		\equal{\violinreverseaxis}{TRUE}
	}{
		\def\kdeaxisx{y}
		\def\kdeaxisy{x}
	}{
		\def\kdeaxisx{x}
		\def\kdeaxisy{y}
	}

	\ifthenelse{%
		\equal{\bandwith}{}%
	}{%
		\pgfplotstableforeachcolumnelement{\theindex}\of\theoldtable\as\xi{%
			\pgfmathparse{\kdestddev+(\xi-\kdeaverage)^2}
			\let\kdestddev\pgfmathresult
		}
		\pgfmathparse{sqrt(\kdestddev/(1+\pgfcolsize))}
		\let\kdestddev\pgfmathresult
		\pgfmathparse{1.06*\kdestddev*((1+\pgfcolsize)^0.2)}%
		\let\bandwith\pgfmathresult
	}{%
	}

	\pgfplotstablegetelem{0}{\theindex}\of{\theoldtable}
	\let\smallestelem\pgfplotsretval
	\let\biggestelem\pgfplotsretval
	\pgfplotstableforeachcolumnelement{\theindex}\of\theoldtable\as\xi{%
		\pgfmathparse{%
			\xi > \smallestelem ? int(0) : int(1)%
		}
		\ifthenelse{
			\pgfmathresult = 1
		}{
			\let\smallestelem\xi
		}{
		}
	}
	\pgfmathparse{\smallestelem - 3*\bandwith}
	\let\smallestelem\pgfmathresult

	\pgfplotstableforeachcolumnelement{\theindex}\of\theoldtable\as\xi{%
		\pgfmathparse{%
			\xi < \biggestelem ? int(0) : int(1)%
		}
		\ifthenelse{
			\pgfmathresult = 1
		}{
			\let\biggestelem\xi
		}{
		}
	}
	\pgfmathparse{\biggestelem + 3*\bandwith}
	\let\biggestelem\pgfmathresult

	\pgfplotstableset{
		create on use/list/.style={create col/expr={
			\smallestelem + (\biggestelem-\smallestelem)
			*(\pgfplotstablerow/(\nsamples-1))
		}}
	}


	\pgfplotstablenew[columns={list}]{\nsamples}\thetable

	\pgfmathparse{0.0}
	\let\biggesteleminkde\pgfmathresult

	\pgfplotstablecreatecol[
		create col/assign/.code={
			\pgfmathparse{\pgfcolsize+1}
			\let\pgfcolsize\pgfmathresult
			\pgfmathparse{%
				1.0/(\pgfcolsize*\bandwith*sqrt(2*3.14159265))
			}
			\let\multiplier\pgfmathresult
			\pgfmathparse{0}
			\let\accumkde\pgfmathresult
			\pgfplotstableforeachcolumnelement{\theindex}\of\theoldtable\as\xi{%
				\pgfmathparse{((\xi-\thisrow{list})/\bandwith)}
				\let\exparg\pgfmathresult
				\pgfmathparse{\accumkde + e^(-0.5*\exparg*\exparg)}
				\let\accumkde\pgfmathresult
			}
			\pgfmathparse{\accumkde*\multiplier}
			\let\entry\pgfmathresult
			\pgfkeyslet{/pgfplots/table/create col/next content}\entry
		}
	]{kdecol}\thetable

	\pgfplotstableforeachcolumnelement{kdecol}\of\thetable\as\entry{%
		\pgfmathparse{%
			\entry < \biggesteleminkde ? int(0) : int(1)%
		}
		\ifthenelse{
			\pgfmathresult = 1
		}{
			\let\biggesteleminkde\entry
		}{
		}
	}

	\pgfplotstablemodifyeachcolumnelement{kdecol}\of\thetable\as\cell{%
		\let\pgfplotstablezero\thedelta
		\ifthenelse{
			\pgfplotstablerow = 0
		}{
			\let\cell\pgfplotstablezero
		}{
			\pgfmathparse{int(\nsamples-1)}
			\ifthenelse{
				\pgfplotstablerow = \pgfmathresult
			}{
				\let\cell\pgfplotstablezero
			}{
				\ifthenelse{
					\equal{\violinnomirror}{TRUE}
				}{
					\pgfmathparse{1.9}
				}{
					\pgfmathparse{1}
				}
				\let\mirrormultiplier\pgfmathresult
				\ifthenelse{
					\equal{\violinscaled}{TRUE}
				}{
					\pgfmathparse{\thedelta+\mirrormultiplier*0.5*\cell/\biggesteleminkde}
				}{
					\pgfmathparse{\thedelta+\mirrormultiplier*\cell}
				}
				\let\cell\pgfmathresult
			}
		}
	}

	\ifthenelse{
		\equal{\violinnomirror}{FALSE}
	}{
		\pgfplotstablecreatecol[
			create col/assign/.code={
				\pgfmathparse{-\thisrow{kdecol}+2*\thedelta}
				\let\entry\pgfmathresult
				\pgfkeyslet{/pgfplots/table/create col/next content}\entry
			}
		]{kdecolinv}\thetable
	}{}

	\ifthenelse{
		\equal{\violinreverseaxis}{TRUE}
	}{
		\pgfkeys{
			/pgfplots/xticklabels={,,},
			/pgfplots/yticklabels={\thelabel},
			/pgfplots/ytick={\thedelta},
		}
	}{
		\pgfkeys{
			/pgfplots/yticklabels={,,},
			/pgfplots/xticklabels={\thelabel},
			/pgfplots/xtick={\thedelta},
		}
	}

	\begin{axis}[
		\violinaxisoptions,
		axis on top,
	]
		\addplot[
			no marks,
			color=\thecolor,
		] table [
			\kdeaxisx=kdecol, \kdeaxisy=list
		] {\thetable};
		\addplot[
			no marks,
			fill=\thecolor,
			opacity=0.50,
		] table [
			\kdeaxisx=kdecol, \kdeaxisy=list
		] {\thetable};
		\ifthenelse{
			\equal{\violinnomirror}{FALSE}
		}{
			\addplot[
				no marks,
				color=\thecolor,
			] table [
				\kdeaxisx=kdecolinv, \kdeaxisy=list
			] {\thetable};
			\addplot[
				no marks,
				fill=\thecolor,
				opacity=0.50,
			] table [
				\kdeaxisx=kdecolinv, \kdeaxisy=list
			] {\thetable};
		}{}
		\ifthenelse{
			\equal{\violinreverseaxis}{FALSE}
		}{
			\addplot[
				no marks,
				color=black,
			] coordinates {
				(\thedelta,\pgfkeysvalueof{/pgfplots/ymin})%
				(\thedelta,\pgfkeysvalueof{/pgfplots/ymax})
			};
		}{
			\addplot[
				no marks,
				color=black,
			] coordinates {
				(\pgfkeysvalueof{/pgfplots/xmin},\thedelta)%
				(\pgfkeysvalueof{/pgfplots/xmax},\thedelta)
			};
		}
		\ifthenelse{
			\equal{\violinaverages}{TRUE}
		}{
			\ifthenelse{
				\equal{\violinreverseaxis}{TRUE}
			}{
				\addplot[
					only marks,
					mark=x,
					mark size=3,
					color=black,
					fill=\thecolor,
					fill opacity=0.70,
				] coordinates {
					(\kdeaverage,\thedelta)
				};
			}{
				\addplot[
					only marks,
					mark=x,
					mark size=3,
					color=black,
					fill=\thecolor,
					fill opacity=0.70,
				] coordinates {
					(\thedelta,\kdeaverage)
				};
			}
		}{}
		\ifthenelse{
			\equal{\violindatapoints}{TRUE}
		}{
			\addplot[
				only marks,
				mark=*,
				mark size=1,
				fill=\thecolor,
				opacity=0.30,
			] table [
				\kdeaxisx=deltacol,
				\kdeaxisy=\theindex,
			] {\theoldtable};
		}{}
	\end{axis}

}
