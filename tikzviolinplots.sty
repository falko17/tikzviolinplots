\NeedsTeXFormat{LaTeX2e}[1994/06/01]
\ProvidesPackage{tikzviolinplots}[2021/08/20 v0.6 Violin plot creation in pgfplots]

\RequirePackage{pgfplots}
\RequirePackage{pgfplotstable}
\RequirePackage{ifthen}
\RequirePackage{stringstrings}
\RequirePackage{pgfkeys}


\DeclareOption*{\PackageWarning{tikzviolinplots}{Unknown option: ‘\CurrentOption’}}
\ProcessOptions\relax

\newcommand{\violinsetoptions}[3][]{%

	\def\violin@scaled{FALSE}
	\def\violin@datapoints{FALSE}
	\def\violin@averages{FALSE}
	\def\violin@nomirror{FALSE}
	\def\violin@reverseaxis{FALSE}
	\def\violin@axisoptions{#2}
	\def\violin@otheroptions{#3}

	\@for\kdeoption:=#1\do{
		\noblanks[q]{\kdeoption}
		\ifthenelse{
			\equal{\thestring}{scaled}
		}{
			\def\violin@scaled{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{datapoints}
		}{
			\def\violin@datapoints{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{averages}
		}{
			\def\violin@averages{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{nomirror}
		}{
			\def\violin@nomirror{TRUE}
		}{}
		\ifthenelse{
			\equal{\thestring}{reverseaxis}
		}{
			\def\violin@reverseaxis{TRUE}
		}{}
	}

		\ifthenelse{
			\equal{\violin@reverseaxis}{TRUE}
		}{
			\begin{axis}[
				\violin@axisoptions,
				\violin@otheroptions,
				axis on top,
				yticklabels={,,},
				ymajorticks=false,
			]
			\end{axis}
		}{
			\begin{axis}[
				\violin@axisoptions,
				\violin@otheroptions,
				axis on top,
				xticklabels={,,},
				xmajorticks=false,
			]
			\end{axis}
		}


}

\pgfkeys{
	/violinplot/.is family, /violinplot,
	default/.style = {
		kernel=gaussian,
		bandwidth=NONE,
		index=DATA,
		samples=50,
		relative position=0
		color=black,
		label={LABEL},
		average mark=x,
		average size=3pt,
		average color=black,
		average opacity=1.0,
		average fill=white,
		average fill opacity=0.5,
		points mark=*,
		points size=1pt,
		points color=black,
		points opacity=1.0,
		points fill=black,
		points fill opacity=0.2,
	},
	kernel/.estore in = \violin@kernel,
	bandwidth/.estore in = \violin@bandwidth,
	index/.estore in = \violin@index,
	samples/.estore in = \violin@samples,
	relative position/.estore in = \violin@delta,
	color/.estore in = \violin@color,
	label/.estore in = \violin@label,
	average mark/.estore in = \violin@avg@mark,
	average size/.estore in = \violin@avg@size,
	average color/.estore in = \violin@avg@color,
	average opacity/.estore in = \violin@avg@opacity,
	average fill/.estore in = \violin@avg@fillcolor,
	average fill opacity/.estore in = \violin@avg@fillopacity,
	points mark/.estore in = \violin@pts@mark,
	points size/.estore in = \violin@pts@size,
	points color/.estore in = \violin@pts@color,
	points opacity/.estore in = \violin@pts@opacity,
	points fill/.estore in = \violin@pts@fillcolor,
	points fill opacity/.estore in = \violin@pts@fillopacity,
}

\newcommand{\violinplot}[2][1]{%

	\pgfkeys{/violinplot, default, #1}

	\def\violin@filename{#2}

	\pgfplotstableread{\violin@filename}\theviolin@dataset@table

	\pgfplotstablegetrowsof{\theviolin@dataset@table}
	\pgfmathparse{int(\pgfmathresult-1)}
	\let\violin@filename@lastindex\pgfmathresult

	\pgfmathparse{0}
	\let\violin@dataset@stddev\pgfmathresult
	\let\violin@dataset@average\pgfmathresult

	\pgfplotstableforeachcolumnelement{\violin@index}\of\theviolin@dataset@table\as\xi{%
		\pgfmathparse{\violin@dataset@average+(\xi/(1+\violin@filename@lastindex))}
		\let\violin@dataset@average\pgfmathresult
	}

	\ifthenelse{
		\equal{\violin@datapoints}{TRUE}
	}{
		\pgfplotstablecreatecol[
			create col/assign/.code={
				\let\entry\violin@delta
				\pgfkeyslet{/pgfplots/table/create col/next content}\entry
			}
		]{deltacol}\theviolin@dataset@table
	}{}

	\ifthenelse{
		\equal{\violin@reverseaxis}{TRUE}
	}{
		\def\violin@axis@x{y}
		\def\violin@axis@y{x}
	}{
		\def\violin@axis@x{x}
		\def\violin@axis@y{y}
	}

	\ifthenelse{%
		\equal{\violin@bandwidth}{NONE}%
	}{%
		\pgfplotstableforeachcolumnelement{\violin@index}\of\theviolin@dataset@table\as\xi{%
			\pgfmathparse{\violin@dataset@stddev+(\xi-\violin@dataset@average)^2}
			\let\violin@dataset@stddev\pgfmathresult
		}
		\pgfmathparse{sqrt(\violin@dataset@stddev/(1+\violin@filename@lastindex))}
		\let\violin@dataset@stddev\pgfmathresult
		\pgfmathparse{1.06*\violin@dataset@stddev*((1+\violin@filename@lastindex)^(-0.2))}%
		\let\violin@bandwidth\pgfmathresult
	}{%
	}

	\pgfplotstablegetelem{0}{\violin@index}\of{\theviolin@dataset@table}
	\let\violin@dataset@min\pgfplotsretval
	\let\violin@dataset@max\pgfplotsretval
	\pgfplotstableforeachcolumnelement{\violin@index}\of\theviolin@dataset@table\as\xi{%
		\pgfmathparse{%
			\xi > \violin@dataset@min ? int(0) : int(1)%
		}
		\ifthenelse{
			\pgfmathresult = 1
		}{
			\let\violin@dataset@min\xi
		}{
		}
	}
	\pgfmathparse{\violin@dataset@min - 3*\violin@bandwidth}
	\let\violin@dataset@min\pgfmathresult

	\pgfplotstableforeachcolumnelement{\violin@index}\of\theviolin@dataset@table\as\xi{%
		\pgfmathparse{%
			\xi < \violin@dataset@max ? int(0) : int(1)%
		}
		\ifthenelse{
			\pgfmathresult = 1
		}{
			\let\violin@dataset@max\xi
		}{
		}
	}
	\pgfmathparse{\violin@dataset@max + 3*\violin@bandwidth}
	\let\violin@dataset@max\pgfmathresult

	\pgfplotstableset{
		create on use/list/.style={create col/expr={
			\violin@dataset@min + (\violin@dataset@max-\violin@dataset@min)
			*(\pgfplotstablerow/(\violin@samples-1))
		}}
	}


	\pgfplotstablenew[columns={list}]{\violin@samples}\violin@kde

	\pgfmathparse{0.0}
	\let\violin@kde@max\pgfmathresult

	\pgfplotstablecreatecol[
		create col/assign/.code={
			\pgfmathparse{\violin@filename@lastindex+1}
			\let\violin@filename@lastindex\pgfmathresult
			\pgfmathparse{%
				1.0/(\violin@filename@lastindex*\violin@bandwidth)
			}
			\let\violin@kde@factor\pgfmathresult
			\pgfmathparse{0}
			\let\violin@kde@accum\pgfmathresult
			\pgfplotstableforeachcolumnelement{\violin@index}\of\theviolin@dataset@table\as\xi{%
				\pgfmathparse{%
					((\xi-\thisrow{list})/%
					\violin@bandwidth)}
				\let\violin@u\pgfmathresult
				\ifthenelse{
					\equal{\violin@kernel}{gaussian}
				}{
					\pgfmathparse{\violin@kde@accum + %
						e^(-0.5*\violin@u*\violin@u)/sqrt(2*pi)}
					\let\violin@kde@accum\pgfmathresult
				}{}
				\ifthenelse{
					\equal{\violin@kernel}{logistic}
				}{
					\pgfmathparse{\violin@kde@accum + %
						1/(e^\violin@u + 2 + e^(-\violin@u))
					}
					\let\violin@kde@accum\pgfmathresult
				}{}
				\ifthenelse{
					\equal{\violin@kernel}{parabolic}
				}{
					\pgfmathparse{%
						abs(\violin@u) < 1 ? int(0) : int(1)%
					}
					\ifthenelse{
						\equal{\pgfmathresult}{0}
					}{
						\pgfmathparse{\violin@kde@accum + %
							0.75*(1-\violin@u*\violin@u)
						}
					}{
						\pgfmathparse{\violin@kde@accum}
					}
					\let\violin@kde@accum\pgfmathresult
				}{}
				\ifthenelse{
					\equal{\violin@kernel}{uniform}
				}{
					\pgfmathparse{%
						abs(\violin@u) < 1 ? int(0) : int(1)%
					}
					\ifthenelse{
						\equal{\pgfmathresult}{0}
					}{
						\pgfmathparse{\violin@kde@accum + 0.5}
					}{
						\pgfmathparse{\violin@kde@accum}
					}
					\let\violin@kde@accum\pgfmathresult
				}{}
				\ifthenelse{
					\equal{\violin@kernel}{triangular}
				}{
					\pgfmathparse{%
						abs(\violin@u) < 1 ? int(0) : int(1)%
					}
					\ifthenelse{
						\equal{\pgfmathresult}{0}
					}{
						\pgfmathparse{\violin@kde@accum + %
							1-abs(\violin@u)}
					}{
						\pgfmathparse{\violin@kde@accum}
					}
					\let\violin@kde@accum\pgfmathresult
				}{}
			}
			\pgfmathparse{\violin@kde@accum*\violin@kde@factor}
			\let\entry\pgfmathresult
			\pgfkeyslet{/pgfplots/table/create col/next content}\entry
		}
	]{kdecol}\violin@kde

	\pgfplotstableforeachcolumnelement{kdecol}\of\violin@kde\as\entry{%
		\pgfmathparse{%
			\entry < \violin@kde@max ? int(0) : int(1)%
		}
		\ifthenelse{
			\pgfmathresult = 1
		}{
			\let\violin@kde@max\entry
		}{
		}
	}

	\pgfplotstablemodifyeachcolumnelement{kdecol}\of\violin@kde\as\cell{%
		\let\pgfplotstablezero\violin@delta
		\ifthenelse{
			\pgfplotstablerow = 0
		}{
			\let\cell\pgfplotstablezero
		}{
			\pgfmathparse{int(\violin@samples-1)}
			\ifthenelse{
				\pgfplotstablerow = \pgfmathresult
			}{
				\let\cell\pgfplotstablezero
			}{
				\ifthenelse{
					\equal{\violin@nomirror}{TRUE}
				}{
					\pgfmathparse{1.9}
				}{
					\pgfmathparse{1}
				}
				\let\violin@mirror@factor\pgfmathresult
				\ifthenelse{
					\equal{\violin@scaled}{TRUE}
				}{
					\pgfmathparse{\violin@delta+\violin@mirror@factor*0.5*\cell/\violin@kde@max}
				}{
					\pgfmathparse{\violin@delta+\violin@mirror@factor*\cell}
				}
				\let\cell\pgfmathresult
			}
		}
	}

	\ifthenelse{
		\equal{\violin@nomirror}{FALSE}
	}{
		\pgfplotstablecreatecol[
			create col/assign/.code={
				\pgfmathparse{-\thisrow{kdecol}+2*\violin@delta}
				\let\entry\pgfmathresult
				\pgfkeyslet{/pgfplots/table/create col/next content}\entry
			}
		]{kdecolinv}\violin@kde
	}{}

	\ifthenelse{
		\equal{\violin@reverseaxis}{TRUE}
	}{
		\pgfkeys{
			/pgfplots/xticklabels={,,},
			/pgfplots/yticklabels={\violin@label},
			/pgfplots/ytick={\violin@delta},
		}
	}{
		\pgfkeys{
			/pgfplots/yticklabels={,,},
			/pgfplots/xticklabels={\violin@label},
			/pgfplots/xtick={\violin@delta},
		}
	}

	\begin{axis}[
		\violin@axisoptions,
		axis on top,
	]
		\addplot[
			no marks,
			color=\violin@color,
		] table [
			\violin@axis@x=kdecol, \violin@axis@y=list
		] {\violin@kde};
		\addplot[
			no marks,
			fill=\violin@color,
			opacity=0.50,
		] table [
			\violin@axis@x=kdecol, \violin@axis@y=list
		] {\violin@kde};
		\ifthenelse{
			\equal{\violin@nomirror}{FALSE}
		}{
			\addplot[
				no marks,
				color=\violin@color,
			] table [
				\violin@axis@x=kdecolinv, \violin@axis@y=list
			] {\violin@kde};
			\addplot[
				no marks,
				fill=\violin@color,
				opacity=0.50,
			] table [
				\violin@axis@x=kdecolinv, \violin@axis@y=list
			] {\violin@kde};
		}{}
		\ifthenelse{
			\equal{\violin@reverseaxis}{FALSE}
		}{
			\addplot[
				no marks,
				color=black,
			] coordinates {
				(\violin@delta,\pgfkeysvalueof{/pgfplots/ymin})%
				(\violin@delta,\pgfkeysvalueof{/pgfplots/ymax})
			};
		}{
			\addplot[
				no marks,
				color=black,
			] coordinates {
				(\pgfkeysvalueof{/pgfplots/xmin},\violin@delta)%
				(\pgfkeysvalueof{/pgfplots/xmax},\violin@delta)
			};
		}
		\ifthenelse{
			\equal{\violin@averages}{TRUE}
		}{
			\ifthenelse{
				\equal{\violin@reverseaxis}{TRUE}
			}{
				\addplot[
					only marks,
					mark=\violin@avg@mark,
					mark size=\violin@avg@size,
					color=\violin@avg@color,
					opacity=\violin@avg@opacity,
					fill=\violin@avg@fillcolor,
					fill opacity=\violin@avg@fillopacity,
				] coordinates {
					(\violin@dataset@average,\violin@delta)
				};
			}{
				\addplot[
					only marks,
					mark=\violin@avg@mark,
					mark size=\violin@avg@size,
					color=\violin@avg@color,
					opacity=\violin@avg@opacity,
					fill=\violin@avg@fillcolor,
					fill opacity=\violin@avg@fillopacity,
				] coordinates {
					(\violin@delta,\violin@dataset@average)
				};
			}
		}{}
		\ifthenelse{
			\equal{\violin@datapoints}{TRUE}
		}{
			\addplot[
				only marks,
				mark=\violin@pts@mark,
				mark size=\violin@pts@size,
				color=\violin@pts@color,
				opacity=\violin@pts@opacity,
				fill=\violin@pts@fillcolor,
				fill opacity=\violin@pts@fillopacity,
			] table [
				\violin@axis@x=deltacol,
				\violin@axis@y=\violin@index,
			] {\theviolin@dataset@table};
		}{}
	\end{axis}

}
